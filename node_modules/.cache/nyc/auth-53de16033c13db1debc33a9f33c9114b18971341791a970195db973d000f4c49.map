{"version":3,"file":"/Users/yusramahomed/Desktop/seng2021--/se2021-23t1-einvoicing-api-h10a_CHEESECAKE-storage-api/src/functions/auth.ts","sources":["/Users/yusramahomed/Desktop/seng2021--/se2021-23t1-einvoicing-api-h10a_CHEESECAKE-storage-api/src/functions/auth.ts"],"names":[],"mappings":"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","sourcesContent":["import { db } from \"../config/firebase\";\n\nimport {\n  queryLoginValid,\n  queryUserByEmail\n} from \"../service/UserTable\";\nimport {\n  queryCompanyExists,\n  queryCompanyByEmail,\n  queryUserByCompanyKey,\n} from \"../service/CompanyTable\";\nimport * as EmailValidator from \"email-validator\";\nimport HTTPError from \"http-errors\";\nimport bcrypt from \"bcrypt\";\nimport jwt from \"jsonwebtoken\";\nimport { nanoid } from \"nanoid\";\nimport { emit } from \"process\";\n\nasync function authenticateFromDB(token: string) {\n  // connect to db\n  const data = await db.collection(\"users\").get();\n  try {\n    const decodedToken = jwt.verify(token, \"cheesecake\") as jwt.JwtPayload;\n    // return a user id\n    return decodedToken.userId;\n  } catch {\n    throw HTTPError(401, \"Unauthorized: invalid token\");\n  }\n}\n\nasync function authRegisterCompany(\n  companyName: string,\n  companyEmail: string,\n  numEmployees: number,\n  ABN: number\n) {\n  // invalid email\n  if (!EmailValidator.validate(companyEmail)) {\n    throw HTTPError(400, \"Bad request: Email is invalid\");\n  }\n\n  if (ABN.toString().length !== 11) {\n    throw HTTPError(400, \"Bad request: ABN invalid\");\n  }\n  \n  // check if company email already exists\n  const companyEmailExists = await queryCompanyByEmail(companyEmail);\n  if (companyEmailExists) {\n    throw HTTPError(409, \"Company email is already registered\");\n  }\n\n  // check if company already exists\n  const exists = await queryCompanyExists(companyName);\n  if (exists) {\n    throw HTTPError(409, \"Company is already registered.\");\n  }\n\n  try {\n    const company = db.collection(\"companies\");\n\n    // not secure but helpful for early testing\n    const companyKey = nanoid();\n\n    const newCompany = {\n      companyName: companyName,\n      companyEmail: companyEmail,\n      companyKey: companyKey,\n      numEmployees: numEmployees,\n      ABN: ABN,\n    };\n\n    await company.doc(companyName).set(newCompany);\n    return { companyKey: companyKey };\n  } catch (error) {\n    throw HTTPError(500, error.message);\n  }\n}\n\nasync function authRegister(\n  email: string,\n  password: string,\n  name: string,\n  companyKey: string\n) {\n  // invalid email\n  if (!EmailValidator.validate(email)) {\n    throw HTTPError(400, \"Bad request: Email is invalid.\");\n  }\n\n  //  check if email already exists\n  const emailAlreadyExists = await queryUserByEmail(email);\n  if (emailAlreadyExists) {\n    throw HTTPError(409, \"Email is already registered.\");\n  }\n\n  // invalid companyKey\n  const companyKeyExists = await queryUserByCompanyKey(companyKey);\n  if (!companyKeyExists) {\n    throw HTTPError(404, \"Company key does not exist\");\n  }\n\n  try {\n    const user = db.collection(\"users\");\n    const userId = nanoid();\n    // password encryption\n    const saltRounds = 10;\n    const salt = bcrypt.genSaltSync(saltRounds);\n    const hash = bcrypt.hashSync(password, salt);\n\n    // tokens\n    const token = jwt.sign({ userId: userId }, \"cheesecake\", {\n      expiresIn: \"1d\",\n    });\n\n    //find companyName based on company key \n    const querySnapshot = await db\n      .collection(\"companies\")\n      .where(\"companyKey\", \"==\", companyKey)\n      .get();\n    if (querySnapshot.empty) {\n      throw HTTPError(404, \"Company key does not exist\");\n    }\n    const companyData = querySnapshot.docs[0].data();\n\n    const userObject = {\n      userId,\n      email,\n      hash,\n      name,\n      \"companyName\": companyData.companyName,\n      tokens: [token],\n    };\n\n    // set in database\n    await user.doc(userId).set(userObject);\n\n    return {\n      token: token,\n      userId: userId,\n    };\n  } catch (error) {\n    throw HTTPError(500, error.message);\n  }\n}\n\nasync function authLogin(email: string, password: string) {\n\n  // invalid email\n  if (!EmailValidator.validate(email)) {\n    throw HTTPError(400, \"Email is invalid.\");\n  }\n\n  // Check is user with email exists\n  if (!await queryLoginValid(email, password)) {\n    throw HTTPError(401, \"User with this email does not exist or password is incorrect\");\n  }\n\n  // Get userData\n  const querySnapshot = await db\n    .collection(\"users\")\n    .where(\"email\", \"==\", email)\n    .get();\n  const userData = querySnapshot.docs[0].data();\n\n  //Generate token\n  const token = jwt.sign({ userId: userData.userId }, \"cheesecake\", {\n    expiresIn: \"1d\",\n  });\n\n  // Append new token to the existing token array\n  userData.tokens.push(token);\n\n  // Update user document in Firebase\n  await db.collection(\"users\").doc(userData.userId).update({\n    tokens: userData.tokens,\n  });\n\n  return {\n    token: token,\n    userId: userData.userId,\n  };\n}\n\nasync function authLogout(token: string) {\n  //Authenticate token\n  const userId = await authenticateFromDB(token);\n  // find user in db\n  const userRef = db.collection(\"users\").doc(userId);\n  const userDoc = await userRef.get();\n  if (!userDoc.exists) {\n    throw HTTPError(403, \"Invalid token.\");\n  }\n\n  // remove token from user object for that particular user\n  const updatedTokens = userDoc.data().tokens.filter((t: any) => t !== token);\n\n  // update user object in db\n  await userRef.update({ tokens: updatedTokens });\n\n  return {\"message\": \"User logged out succesfully\"}\n}\n\nexport { authRegister, authLogin, authLogout, authRegisterCompany };\n"]}